<!DOCTYPE html>
<html lang="en">
<head>
  <base href="/pose_template_demo/">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="description" content="Simple pose detection template (Flutter + MediaPipe).">
  <meta name="theme-color" content="#000000">
  <title>Pose Detection Template</title>

  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
    }

    #flt-glass-pane, #flutter_view, flt-glass-pane {
      position: relative !important;
      z-index: 9999 !important;
      pointer-events: auto !important;
    }
    canvas, flt-canvas {
      z-index: 9999 !important;
    }

    .no-js {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      color: #fff; text-align: center; padding: 24px; background:#000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
  </style>

  <!-- ===== Pose Landmarker (Web) ======================================== -->
  <script type="module">
    import { PoseLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

    const isHttps = (location.protocol === 'https:' || location.hostname === 'localhost');

    const emit = (name, detail) =>
      window.dispatchEvent(new CustomEvent(name, { detail }));

    const emitError = (msg) => {
      emit('pose:error', { message: msg });
      console.error('[pose] ', msg);
    };

    const pose = {
      stream: null,
      video:  null,
      raf:    null,
      landmarker: null,
      facing: 'front', // 'front' | 'back'
    };

    function ensurePoseVideo() {
      if (pose.video) return;
      const v = document.createElement('video');
      v.id = 'pose-video';
      Object.assign(v.style, {
        position: 'fixed',
        left: '0',
        top: '0',
        width: '100vw',
        height: '100vh',
        objectFit: 'cover',
        transform: 'scaleX(-1)',   // mirror for front camera
        zIndex: '0',
        pointerEvents: 'none',
        background: 'black',
      });
      v.autoplay = true;
      v.muted = true;
      v.playsInline = true;
      document.body.appendChild(v);
      pose.video = v;
    }

    async function poseStartCamera() {
      ensurePoseVideo();
      const isFront = (pose.facing !== 'back');

      const constraints = {
        video: {
          facingMode: isFront ? 'user' : { ideal: 'environment' },
          width:  { ideal: 1280 },
          height: { ideal: 720 },
        },
        audio: false,
      };

      try {
        pose.stream = await navigator.mediaDevices.getUserMedia(constraints);
      } catch (err) {
        // fallback to front if back camera failed
        if (!isFront) {
          console.warn('[pose] back camera failed, fallback to front', err);
          pose.facing = 'front';
          return poseStartCamera();
        }
        throw err;
      }

      pose.video.srcObject = pose.stream;
      await pose.video.play().catch((e) => {
        console.warn('[pose] video.play() failed', e);
      });

      // mirror only for front camera
      pose.video.style.transform = isFront ? 'scaleX(-1)' : 'none';
    }

    async function ensurePoseLandmarker() {
      if (pose.landmarker) return pose.landmarker;
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );
      pose.landmarker = await PoseLandmarker.createFromOptions(fileset, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
        },
        runningMode: "VIDEO",
        numPoses: 1,
        minPoseDetectionConfidence: 0.4,
        minPosePresenceConfidence: 0.4,
        minTrackingConfidence: 0.4,
      });
      return pose.landmarker;
    }

    function toNamedPose(lm) {
      if (!lm || !lm.length) return null;
      const p = (i) => ({ x: lm[i].x, y: lm[i].y });
      return {
        leftShoulder: p(11), rightShoulder: p(12),
        leftElbow:    p(13), rightElbow:    p(14),
        leftWrist:    p(15), rightWrist:    p(16),
        leftHip:      p(23), rightHip:      p(24),
        leftKnee:     p(25), rightKnee:     p(26),
        leftAnkle:    p(27), rightAnkle:    p(28),
      };
    }

    function poseLoop() {
      if (!pose.landmarker || !pose.video) return;
      const now = performance.now();
      try {
        const res = pose.landmarker.detectForVideo(pose.video, now);
        if (res?.landmarks?.length) {
          const named = toNamedPose(res.landmarks[0]);
          if (named) emit('pose', { landmarks: named });
        }
      } catch (e) {
        emitError('pose detectForVideo failed: ' + String(e));
      }
      pose.raf = requestAnimationFrame(poseLoop);
    }

    // Called from Flutter: start pose
    window.poseStart = async function () {
      try {
        if (!isHttps) {
          emitError('Please use HTTPS (or localhost) to access camera.');
          return;
        }

        if (pose.raf) {
          cancelAnimationFrame(pose.raf);
          pose.raf = null;
        }
        if (pose.stream) {
          try { pose.stream.getTracks().forEach(t => t.stop()); } catch (_) {}
          pose.stream = null;
        }

        pose.facing = 'front';
        await poseStartCamera();
        await ensurePoseLandmarker();
        poseLoop();
      } catch (e) {
        emitError('poseStart failed: ' + String(e));
      }
    };

    // Called from Flutter: toggle front/back camera
    window.poseSwitchCamera = async function () {
      try {
        if (!isHttps) {
          emitError('Please use HTTPS (or localhost) to access camera.');
          return;
        }

        if (pose.raf) {
          cancelAnimationFrame(pose.raf);
          pose.raf = null;
        }
        if (pose.stream) {
          try { pose.stream.getTracks().forEach(t => t.stop()); } catch (_) {}
          pose.stream = null;
        }

        pose.facing = (pose.facing === 'front') ? 'back' : 'front';

        await poseStartCamera();
        await ensurePoseLandmarker();
        poseLoop();
      } catch (e) {
        emitError('poseSwitchCamera failed: ' + String(e));
      }
    };

    // Called from Flutter: stop pose
    window.poseStop = async function () {
      if (pose.raf) { cancelAnimationFrame(pose.raf); pose.raf = null; }

      try { await pose.landmarker?.close?.(); } catch (_) {}
      pose.landmarker = null;

      if (pose.stream) {
        try { pose.stream.getTracks().forEach(t => t.stop()); } catch (_) {}
        pose.stream = null;
      }

      if (pose.video) {
        try { pose.video.pause(); pose.video.srcObject = null; } catch (_) {}
        try { pose.video.remove(); } catch (_) {}
        pose.video = null;
      }
    };

    window.addEventListener('error', e =>
      emitError(String(e?.message ?? e))
    );
    window.addEventListener('unhandledrejection', e =>
      emitError(String(e?.reason ?? e))
    );
  </script>
</head>

<body>
  <noscript>
    <div class="no-js">
      This app requires JavaScript and camera permission.<br/>
      Please enable JavaScript and access via HTTPS (or localhost).
    </div>
  </noscript>

  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
